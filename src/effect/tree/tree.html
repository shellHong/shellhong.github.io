<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title></title>
  <meta name="viewport" content="width=1000, initial-scale=1.0, maximum-scale=1, user-scalable=no">
  <style media="screen">
    html,
    body {
      height: 100%;
    }

    svg {
      margin: 0 auto;
    	width: 840px;
    	height: 600px;
    	font-family: helvetica, sans-serif;
    }

    path,
    line {
      stroke: #777;
    }

    .svgField{
      height: 100%;
    }
  </style>
</head>

<body>
  <div class="svgField"><svg></svg></div>
  <script src="./javascript/d3.v3.min.js" charset="utf-8"></script>
  <script type="text/javascript">
    /* D3 Tree */
    /* Copyright 2013 Peter Cook (@prcweb); Licensed MIT */

    // Tree configuration
    var flowers = [];
    var branches = [];
    var seed = {
      i: 0,
      x: 420,
      y: 600,
      a: 0,
      l: 130,
      d: 0
    }; // a = angle, l = length, d = depth
    var da = 0.5; // Angle delta
    var dl = 0.8; // Length delta (factor)
    var ar = 0.7; // Randomness
    var maxDepth = 10;

    // Tree creation functions
    function branch(b) {
      var end = endPt(b),
        daR, newB;

      branches.push(b);

      if (b.d === maxDepth){
        flowers.push(b);
        return;
      }

      // Left branch
      daR = ar * Math.random() - ar * 0.5;
      newB = {
        i: branches.length,
        x: end.x,
        y: end.y,
        a: b.a - da + daR,
        l: b.l * dl,
        d: b.d + 1,
        parent: b.i
      };
      branch(newB);

      // Right branch
      daR = ar * Math.random() - ar * 0.5;
      newB = {
        i: branches.length,
        x: end.x,
        y: end.y,
        a: b.a + da + daR,
        l: b.l * dl,
        d: b.d + 1,
        parent: b.i
      };
      branch(newB);
    }

    function regenerate(initialise) {
      branches = [];
      branch(seed);
      initialise ? create() : update();
    }

    function endPt(b) {
      // Return endpoint of branch
      var x = b.x + b.l * Math.sin(b.a);
      var y = b.y - b.l * Math.cos(b.a);
      return {
        x: x,
        y: y
      };
    }


    // D3 functions
    function x1(d) {
      return d.x;
    }

    function y1(d) {
      return d.y;
    }

    function x2(d) {
      return endPt(d).x;
    }

    function y2(d) {
      return endPt(d).y;
    }

    function highlightParents(d) {
      var colour = d3.event.type === 'mouseover' ? 'green' : '#777';
      var depth = d.d;
      for (var i = 0; i <= depth; i++) {
        d3.select('#id-' + parseInt(d.i)).style('stroke', colour);
        d = branches[d.parent];
      }
    }

    function create() {
      var stepDelay = 10;
      var flowStepDelay = 10;
      var duration = 500;
      d3.select('svg')
        .selectAll('line')
        .data(branches)
        .enter()
        .append('line')
        .attr('x1', x1)
        .attr('y1', y1)
        .attr('x2', x1)
        .attr('y2', y1)
        .style('stroke-width', function(d) {
          return parseInt(maxDepth + 1 - d.d) + 'px';
        })
        .attr('id', function(d) {
          return 'id-' + d.i;
        })
        // .on('mouseover', highlightParents)
        // .on('mouseout', highlightParents)
        .transition()
    		.delay(function(d,i){
    			return i * stepDelay;
    		})
    		.duration(duration)
    		.ease("linear")
        .attr('x2', x2)
        .attr('y2', y2);

        setTimeout(function(){
          d3.select('svg')
            .append("defs")
            .append("filter")
            .attr("id", "Gaussian_Blur")
            .append("feGaussianBlur")
            .attr("in", "SourceGraphic")
            .attr("stdDeviation", 2);


          d3.select('svg')
            .selectAll('circle')
            .data(flowers)
            .enter()
            .append('circle')
            .attr('cx', x2)
            .attr('cy', y2)
            .attr('r', 0)
            .attr('fill', 'pink')
            .transition()
        		.delay(function(d,i){
        			return i % 3;
        		})
        		.duration(duration)
            .attr('r', 5)
            .style("filter", "url(#Gaussian_Blur)");

        }, branches.length * stepDelay + duration);
    }

    regenerate(true);
  </script>
</body>

</html>
